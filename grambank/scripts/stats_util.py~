from itertools import groupby, chain

uchar = '?'
undefined = {}
undefined['?'] = uchar
undefined['n/a'] = uchar
undefined['N/A'] = uchar
undefined['n.a.'] = uchar
undefined['n.a'] = uchar
undefined['N.A.'] = uchar
undefined['N.A'] = uchar
undefined['-'] = uchar
undefined[''] = uchar
undefined[None] = uchar
undefined[()] = uchar
undefined["NODATA"] = uchar
undefined['? - Not known'] = uchar

def grp(xs):
    return dict([(g, [tup[1:] for tup in tups]) for (g, tups) in groupby(xs, lambda x: x[0])])

def leaves(d):
    if not d:
        return set()
    l = set([k for (k, v) in d.iteritems() if not v])
    return l.union(chain(*[leaves(v) for (k, v) in d.iteritems() if v]))

def paths_to_d(pths):
    if pths == [()] or pths == [[]]:
        return None
    return dict([(p, paths_to_d(tails)) for (p, tails) in grp(pths).iteritems()])

def sumds(ds):
    r = {}
    for (i, v) in chain(*[d.iteritems() for d in ds]):
        r[i] = r.get(i, 0) + v
    return r

def stability_tp(lv, fp):
    print "Stability", "LV", len(lv), "FP", fp.items()[:10]
    ftp = {}
    for (fam, famt) in fp.iteritems():
        print "kolla", fam, leaves({fam: famt}), lv.keys()
        if not leaves({fam: famt}).intersection(lv):
            continue
        (t, pr) = prr(fam, lv, fp)
        print fam, t
        if not t:
            continue
        tr = transitions(t)
        ftp[fam] = [((tf, tt), (pr[tf], pr[tt])) for (tf, tt) in tr]
    return ftp        

def prune(d, lvs):
    if not d:
        return d
    ls = [(k, v) for (k, v) in d.iteritems() if not v and k in lvs]
    sdl = [(k, prune(v, lvs)) for (k, v) in d.iteritems() if v]
    return dict(ls + [(k, v) for (k, v) in sdl if v and len(v) != 1] + [(a, b) for (k, v) in sdl if v and len(v) == 1 for (a, b) in v.iteritems()])


def prr(f, a, fp):
    dlgs = leaves(fp.get(f, dict.fromkeys(a))).intersection([lg for (lg, v) in a.iteritems() if not undefined.has_key(v)])
    t = prune({f: fp.get(f, dict.fromkeys(a))}, dlgs)
    done = parsimony_reconstruct(t, a)
    r = dict([(k, v) for (k, v) in a.iteritems() if k in dlgs])
    for (n, rd) in done.iteritems():
        r[n] = '/'.join(allmax(rd, min).keys())
    return (t, r)

def transitions(t):
    if not t:
        return []
    thislev = [(k, kp) for (k, v) in t.iteritems() if v for kp in v.keys()]
    return thislev + [ti for (k, v) in t.iteritems() if v for ti in transitions(v)]

def trcount(tp):
    tpc = [[(tfi, tti) for tfi in tf.split("/") for tti in tt.split("/")] for (tf, tt) in tp]
    s = {}
    for (k, v) in [((tfi, tti), 1/float(len(tpci))) for tpci in tpc for (tfi, tti) in tpci]:
        s[k] = s.get(k, 0) + v
    return s

def stability_ftp(lv, fp):
    return dict([(l, trcount([(tf, tt) for (label, (tf, tt)) in labeled_tr])) for (l, labeled_tr) in stability_tp(lv, fp).iteritems()])


def feature_stability(datatriples, clfps):
    clf = paths_to_d(clfps)
    print "datatriples", len(datatriples), datatriples[:3]
    flv = dict([(feature, dict([(lg, val) for (lg, _, val) in lfvs])) for (feature, lfvs) in groupby([(f, l, v) for (l, f, v) in datatriples], lambda (f, l, v): f)])
    print "hej", [(x, list(ys)) for (x, ys) in groupby(datatriples, lambda (l, f, v): f)][0]
    print "flv", len(flv), flv[u'GB051']
    return [(f, parsimony_stability(lv, clf)) for (f, lv) in flv.iteritems()]

def parsimony_stability(lv, fp):
    ftp = stability_ftp(lv, fp)
    #print len(ftp), ftp.items()[0]
    u = sumds(ftp.values())    
    stability = sum([v for ((a, b), v) in u.iteritems() if a == b])
    total = float(sum(u.values()))
    if total == 0.0:
        return {"stability": None, "retentions": stability, "transitions": total}
    return {"stability": stability/total, "retentions": stability, "transitions": total}

def parsimony_reconstruct(fp, r):
    done = {}
    def rec(d):
        if not d:
            return None
        t = {}
        for (k, v) in d.iteritems():
            if done.has_key(k):
                t[k] = done[k]
                continue
            if v:
                t[k] = rec(v)
                done[k] = t[k]
                continue
            if r.has_key(k) and r[k] != "NODATA": #TODO
                t[k] = {r[k]: 0}

        tvals = [x for x in t.values() if x != None]
        if not tvals:
            return None
        return dict([(k, sum([min(d.get(k, 1), 1+min(d.values())) for d in tvals])) for k in types])
    types = set(r.values())
    rd = rec(fp)
    return done #allmax(rd, min)




def lg(z):
    if z == 0:
        return 0.0
    return math.log(z, 2)

def ent(pij, pi, pj):
    return pij*lg(pij/(pi*pj))

def entp(pd):
    return -sum([px * lg(px) for px in pd.itervalues()])

def I(X, Y, XY):    
    I = sum([ent(XY.get((x, y), 0), px, py) for (x, px) in X.iteritems() for (y, py) in Y.iteritems()])
    return I

#E.g. X = {L1: 'a', L2: 'a'} Y = {L1: 'a', L2: 'b'}
def implies(X, Y):
    (x, y, xy) = jnt(X, Y)
    return pi(x, y, xy)

def jnt(X, Y):
    U = set(X.iterkeys()).intersection(Y)
    XY = dict([(z, (X[z], Y[z])) for z in U])
    x = norm(fd([X[z] for z in U]))
    y = norm(fd([Y[z] for z in U]))
    xy = norm(fd([XY[z] for z in U]))
    return (x, y, xy)


def pi(X, Y, XY):
    i = I(X, Y, XY) 
    iy = entp(Y)
    if iy == 0.0:
        return 0.0
    return i/iy

def deepfamilies():
    a = 1
    #PRR
    #Stability
    #Sim = Ham * stab




